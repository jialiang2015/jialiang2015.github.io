<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>八股文</title>
    <link href="/jialiang2015.github.io/2021/04/30/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/jialiang2015.github.io/2021/04/30/%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\jialiang2015.github.io\assets\css\APlayer.min.css"><script src="\jialiang2015.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-ORM是什么？"><a href="#1-ORM是什么？" class="headerlink" title="1.ORM是什么？"></a>1.ORM是什么？</h2><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h2 id="2-Hibernate与MyBatis的区别？"><a href="#2-Hibernate与MyBatis的区别？" class="headerlink" title="2.Hibernate与MyBatis的区别？"></a>2.Hibernate与MyBatis的区别？</h2><p>相同点：<br>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。<br>不同点：<br><strong>映射关系</strong><br>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关系关联配置简单<br>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂<br><strong>SQL优化和移植性</strong><br>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。<br>MyBatis 需要手动编写 SQL，支持动态SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。<br><strong>开发难易程度和学习成本</strong><br>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统<br>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统<br><strong>总结</strong><br>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，<br>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架</p><h2 id="3-什么是对象拷贝？什么是浅拷贝，什么是深拷贝？"><a href="#3-什么是对象拷贝？什么是浅拷贝，什么是深拷贝？" class="headerlink" title="3.什么是对象拷贝？什么是浅拷贝，什么是深拷贝？"></a>3.什么是对象拷贝？什么是浅拷贝，什么是深拷贝？</h2><p><strong>基本类型拷贝:</strong><br>克隆是针对于对象而言的,基本类型(boolean,char,byte,short,float,double.long)已久具备自身克隆的特性.如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> y=x;<br>System.out.println(x);<span class="hljs-comment">//1</span><br>System.out.println(y);<span class="hljs-comment">//1</span><br>y=<span class="hljs-number">2</span>;<br>System.out.println(x);<span class="hljs-comment">//1</span><br>System.out.println(y);<span class="hljs-comment">//2</span><br></code></pre></div></td></tr></table></figure><p><strong>JVM实现拷贝的目的:</strong></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">那么我把这个对象的临时属性一个一个的赋值给我新 <span class="hljs-keyword">new</span> <span class="hljs-type"></span>的对象不也行嘛？<br></code></pre></div></td></tr></table></figure><blockquote><p>答案是：克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的 “状态” 就靠 clone 方法了。</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">那么我把这个对象的临时属性一个一个的赋值给我新 <span class="hljs-keyword">new</span> <span class="hljs-type"></span>的对象不也行嘛？<br></code></pre></div></td></tr></table></figure><blockquote><p>可以是可以，但是一来麻烦不说，二来，大家通过上面的源码都发现了 clone 是一个 native 方法，就是快啊，在底层实现的。</p></blockquote><p><strong>浅拷贝</strong><br>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。<br>简单点说，就是对象中的基本数据类型(boolean,char,byte,short,float,double.long)进行值传递的，其余的是将字段指向同一个内存地址，从而达到值一样。<br><strong>深拷贝</strong><br>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。<br><strong>所以区别在于是否有新对象创建。</strong></p><h2 id="4-常用的集合"><a href="#4-常用的集合" class="headerlink" title="4.常用的集合"></a>4.常用的集合</h2><h3 id="4-1-说说List-Set-Map三者的区别？"><a href="#4-1-说说List-Set-Map三者的区别？" class="headerlink" title="4-1. 说说List,Set,Map三者的区别？"></a>4-1. 说说List,Set,Map三者的区别？</h3><ul><li>List (对付顺序的好帮⼿)： 存储的元素是有序的、可重复的。</li><li>Set (注重独⼀⽆⼆的性质): 存储的元素是⽆序的、不可重复的。</li><li>Map (⽤ Key 来搜索的专家): 使⽤键值对（kye-value）存储，类似于数学上的函数<br>y=f(x)，“x”代表 key，”y”代表 value，Key 是⽆序的、不可重复的，value 是⽆序的、可重复的，每个键最多映射到⼀个值。</li></ul><h3 id="4-2-Arraylist-与-LinkedList-区别"><a href="#4-2-Arraylist-与-LinkedList-区别" class="headerlink" title="4-2.Arraylist 与 LinkedList 区别?"></a>4-2.Arraylist 与 LinkedList 区别?</h3><blockquote><ol><li>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： Arraylist 底层使⽤的是 Object 数组； LinkedList 底层使⽤的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下⾯有介绍到！）</li><li>插⼊和删除是否受元素位置的影响： ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i插⼊和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。 ②LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, Eelement) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。</li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/jialiang2015.github.io/2021/04/27/hello-world/"/>
    <url>/jialiang2015.github.io/2021/04/27/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\jialiang2015.github.io\assets\css\APlayer.min.css"><script src="\jialiang2015.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
